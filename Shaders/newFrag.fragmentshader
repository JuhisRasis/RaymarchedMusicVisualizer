#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;


 uniform float time;

 vec3 objcol;

 //code c is the repetition period (which can be different in each coordinate direction). This will work great for primitives that have a bounding box smaller than half the repetition period. 

 mat2 rot(float a){
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}


float sdEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) -.1 + min(max(q.x,max(q.y,q.z)),0.0);
}

 float GetDist(vec3 p){
    vec4 s = vec4(sin(time) * 5, 5, 0., 1);


    float sphereDist = length(p -s.xyz) - s.w;

    float fra = length(p)/1-.5;




    float rad = .2;


    rad = 0.1*pow(0.5 +0.5*cos(45.* atan(p.x,p.y)),1);
    //rad -= -.5 + 0.8*sin(p.x);




    float d = length(p) - .7;

    //d = min(d,sdBox(p, vec3(5,2.5,5))- .5);



    //s = vec4(1, 1, 1, 1);


    
    d = min(d,length(p -s.xyz) - .7 -rad);

    //d = length(max(q ,0.0)) + min(max(q.x, max(q.y,q.z)),-1 * 1);


    vec3 c = vec3(3,3,3);

    vec3 q = mod(p+0.5*c -s.xyz,c)-0.5*c;
    d = sdBox(q, vec3(1.,1.,1.) -.5) -rad;
    d *= 0.8;



    float planeDist = p.y;
    d = min(d, planeDist);






    //objcol = abs(p) / 8;
    objcol=vec3(0,1.,1.);


    return d;
 
 }

 vec3 GetNormal(vec3 p){
    float d = GetDist(p);
    vec2 e = vec2(.01, 0);

    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));


        return normalize(n);
 }

  vec3 normal(vec3 p) {
    vec2 d = vec2(0., .01);
    return normalize(vec3(GetDist(p+d.yxx), GetDist(p+d.xyx), GetDist(p+d.xxy))-GetDist(p));
}
 
 // rayOrigin rayDirection

 float RayMarch(vec3 ro, vec3 rd){
 float d0 = 0.;

 for (int i = 0; i<100; i++){
    vec3 p = ro + rd*d0;
    float distanceToScene = GetDist(p);
    d0 += distanceToScene;
    if(d0>100. || distanceToScene<.01)
    break;

    }
 return d0;
 }

 float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

 float GetLight(vec3 p)
 {
 vec3 lightPos = vec3(0, 10, 0);
 lightPos.xz += vec2(0 , time * 15 + 50);
 vec3 l = normalize(lightPos-p);
 vec3 n = GetNormal(p);

 
 float dif = clamp(dot(n, l), 0., 1.);
 float d = RayMarch(p+n * .02, l);
 if(d<length(lightPos-p)) dif *= .1;


 return dif;

 }

 vec3 March(vec3 from, vec3 dir)
{
    float d = 0., td = 0., maxdist = 20.;
    vec3 p = from, col = vec3(0.);
    vec3 secondMatchDir = dir;

    for (int i = 0; i<100; i++)
    {
        float d2 = GetDist(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);

        if (d2<-0)
        {
            vec3 n = normal(p);
            dir = reflect(dir, n); // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml
            d2 = .1;
          
        }
        d = max(.01, abs(d2));
        p += d * dir;
        td += d;
        if (td>maxdist) break;
        col += .01 * objcol;
    }

    float d3 = RayMarch(from,secondMatchDir);


    vec3 p2 = from + secondMatchDir * d3;

    float dif = GetLight(p2);
    vec3 col2 = vec3(dif);


    return pow(col + col2, vec3(2.));
}


// vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - .5;
void main()
{
   

     vec2 uv = (vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - vec2(+0.8, +0.3)) * 2;
     uv.x *= .5f;

    vec3 from = vec3(2 ,10, time * 15); // cameraPos
    vec3 dir = normalize(vec3(uv, 1));


    vec3 col = vec3(0);


    col = March(from, dir);



    fragColor = vec4(col,1.0);
}

// Vector multipiclations
// The Vector Dot Product dot() == float
// The Vector Dot Product cross() == vec
// min() Returns the smallest of a and b. If both are equivalent, a is returned.
// abs() return the absolute value of the parameter























