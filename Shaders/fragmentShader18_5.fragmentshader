#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;
     vec2 asd;
 int time_Counter = 0;
 uniform float time;
 bool rotPhase1 = true;
 vec3 objcol;
 bool inLoop = false;
 int loopTimer = 0;
 vec3 boxSize = vec3(3,3,3);


 //code c is the repetition period (which can be different in each coordinate direction). This will work great for primitives that have a bounding box smaller than half the repetition period. 

 mat2 rot(float a){
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}


float sdEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) -.1 + min(max(q.x,max(q.y,q.z)),0.0);
}

 float GetDist(vec3 p, vec3 multiplier){
    vec4 s = vec4(sin(time) * 5, 5, 0., 1);

    float sphereDist = length(p -s.xyz) - s.w;



    

    float rad = .0;


    //21.5
    //rad -= -2 *clamp(sin(time * 22.5), 0.6, 1);

    rad -= .9*(sin(p.x))*sin(time/3);
        //rad -= .9*(sin(p.y))*sin(time/3);
                rad -= .9*(sin(p.z))*sin(time/3);

    //rad -= sin(p.x) - sin(p.y);

    //p.xz *= rot(sin(time));


    if(sin(time/7) > .5){
    rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.y)),1);
    //p.yx *= rot(time);
    //p.zx *= rot(time);

    }
    else{
    //p.zx *= rot(time);
    //rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.z)),1);

    }

    float d = length(p);

    //d = min(d,sdBox(p, boxSize)- .5);

    d = min(d,length(p -s.xyz));

    boxSize = vec3(12,             5,              clamp(sin(time) * 7, 5, 7));


    vec3 c = vec3(25,25,25);

    vec3 q = mod(p+0.5*c,c)-0.5*c;
    d = sdEllipsoid(q, boxSize -.5) -rad;




    //float planeDist = p.y;
    //d = min(d, planeDist);



    //objcol += vec3(.5,.6,0);

    objcol = abs(p) / 20;

    //objcol=vec3(0,1.,1.);


    return d;
 
 }



  vec3 normal(vec3 p, vec3 multiplier) {
    vec2 d = vec2(0., .01);
    return normalize(vec3(GetDist(p+d.yxx, multiplier), GetDist(p+d.xyx, multiplier), GetDist(p+d.xxy, multiplier))-GetDist(p, multiplier));
}
 


 float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}



 vec3 March(vec3 from, vec3 dir)
{
    float d = 0., tracingDistance = 0.,tr = 0.,  maxdist = 50.;
    vec3 p = from, col = vec3(0.), transparent = vec3(0.);
    vec3 startDir = dir;
    for (int i = 0; i<100; i++)
    {
        float d2 = GetDist(p, vec3(1,1,1));

        if (d2<0)
        {
            vec3 n = normal(p, vec3(1,1,1));
            dir = reflect(dir, n);
            d2 = .1;
          
        }
        d = max(.01, d2);
        p += d * dir;

        tracingDistance += d;
        if (tracingDistance>maxdist) break;
        col += .02 * objcol;
    }

    tracingDistance = 0.;
    p = from;
    d = 0.;
    dir = startDir;
    for (int i = 0; i<100; i++)
    {
        float d2 = GetDist(p, vec3(3,3,3)) * (1.-hash12(gl_FragCoord.xy+time)*.2);

        if (d2<-.9)
        {
            vec3 n = normal(p, vec3(1,1,1));
            dir = reflect(dir, n);
            d2 = .1;
          
        }
        d = max(.01, d2);
        p += d * dir;

        tr += d;
        if (tr>maxdist) break;
        transparent += vec3(.06,.05,.05);
    }

    //vec3 colour = mix(transparent, col,.90f);

    return pow(col, vec3(2.));
}


// vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - .5;
void main()
{
   

     vec2 uv = (vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - vec2(+1.1, +0.33)) * 2;
     uv.x *= .5f;
    vec3 from = vec3(2 ,10, -18 + sin(time) * 10); // cameraPos
    vec3 dir = normalize(vec3(uv, 1));
    vec3 col = vec3(0);
    col = March(from, dir);
    fragColor = vec4(col,1.0);
}

// Vector multipiclations
// The Vector Dot Product dot() == float
// The Vector Dot Product cross() == vec
// min() Returns the smallest of a and b. If both are equivalent, a is returned.
// abs() return the absolute value of the parameter