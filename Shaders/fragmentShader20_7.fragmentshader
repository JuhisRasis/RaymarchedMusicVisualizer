#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;


 uniform float time;
 uniform float sinTime; 
vec3 objcol;
float bounce;

// Filmic tonemapping curve by milesWaugh

const float epsilon = 0.001;
const float focalLength = 1.;
const float renderDist = 850.;
const float pi = 3.141592653589793;
const int bounces = 5;

vec3 camera;
float nearestDist;
vec3 ray;

vec3 surfCol;
vec3 surfNormal;
float surfRoughness;
int surfType; /* 0=dielectric 1=metallic */
bool updateMat;

float diffuse = 0.;
float specular;
vec3 ambient = 1.*vec3(.3, 0.4, 0.7);

vec3 rayDirection( float focal, vec2 xy ) {
    return (normalize(vec3(xy, focal)));
}

// SDF's

vec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {
    vec3 offset = pos - rayOrigin;
    float dot1 = dot(offset, rayDir);
    float dot2 = dot(offset, offset);
    if (dot1 < 0.) {
        return vec4(-1., 0, 0, 0);
    }
    if (dot2 - dot1 * dot1 < radius * radius) {
        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));
        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);
    }
    return vec4(-1., 0, 0, 0);
}

vec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {
    float dot1 = dot(normal, rayDir);
    float near = (dot(normal, rayOrigin) + dist)/dot1;
    if (!(dot1 == 0.) && near < 0.)
    {
        return vec4(-near, normal);
    }
    return vec4(-1., 0, 0, 0);
}

void addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic */) {
    float dist = surface.x;
    if ( dist < nearestDist && dist > 0. ) {
        nearestDist = dist;
        if (updateMat) {
        	surfCol = col;
            surfRoughness = roughness*roughness;
            surfNormal = normalize(surface.yzw);
            surfType = type;
        }
    }
}

float scene( vec3 rayOrigin, vec3 rayDir)
{
    
    vec3 sinVector = vec3(1., 0.81, 1.23);
    
    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);
    
    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 3, 18), sin(time/ 2) * 2 + 1), vec3(0.4,.2, 0.01), .1, 0);

    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.5, 0.1, 0.1), .1, 0);
    
    return nearestDist;
}

vec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {
    updateMat = updateMaterial;
    
    nearestDist = renderDist;
        
    scene(start, rayDir);
        
    if ( nearestDist < renderDist ) {
        return vec4(1, rayDir * nearestDist + start);
    }
    else {
        return vec4(0., rayDir * nearestDist + start);
    }
}

float GGX (float halfDot, float roughness) {
    float r2 = roughness*roughness;
    float a = halfDot * halfDot * (r2 - 1.) + 1.;
    return r2 / (a * a);
}

void directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {
    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {
        float lambertian = dot(surfNormal, lightDir);
        diffuse += max(intensity * lambertian, 0.);
		
        vec3 halfway = normalize(lightDir - rayDir);
        float halfDot = dot(surfNormal, halfway);
    	specular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);

    }
}

void pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {
    vec3 lightDir = normalize(position - ray);
    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );
}

void sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {
    pointLight( ray, rayDir, vec3(-10, 50, 20), 2.5, surfNormal);
    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );
}

// My implementation of the tonemapping curve by milesWaugh
vec3 filmic(vec3 color) {
    //return color;
    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));
}

float fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {
    float F0 = (1. - IOR)/(1. + IOR);
    F0 *= F0;
    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));
}

vec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {
    diffuse = 0.;
    specular = 0.;
    
    sceneLights(ray, rayDir, surfNormal);

    
    vec3 finalCol = vec3(0.);
    
    if (surfType == 0) {
        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);
    }
    else if (surfType == 1) {
        finalCol = mix(surfCol * specular, vec3(specular), f);
    }
    
    finalCol = finalCol;
    
    return finalCol;
}

vec3 renderFromRay(vec3 rayDir, vec3 rayOrigin) {
    vec3 contribution = vec3(1.0);
    vec3 combinedCol;
    float totalDepth = 0.;
    float foga;
    for (int i = 0; i < bounces; i++) {
        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );

        if (rayData.x == 1.) {
            totalDepth += distance(rayData.yzw, rayOrigin);
            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);
            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);
            if (surfType == 0) {
                contribution *= f;
            }
            else if (surfType == 1) {
                contribution *= mix(surfCol, vec3(1.), vec3(f));
            }
            
            rayDir = reflect(rayDir, surfNormal);
            rayOrigin = rayData.yzw + epsilon * surfNormal;
        }
        else {
            combinedCol += contribution * ambient;
            break;
        }
    }
    return combinedCol;
}
void main()
{
   

    vec2 uv = (vec2(gl_FragCoord.x, gl_FragCoord.y) / vec2(1920, 1920)) -.5;
    vec3 rayDir = rayDirection( focalLength, uv );
    camera = vec3(0,5,sin(time) * 3);
    vec3 col = renderFromRay(rayDir, camera);
    
    // Output to screen, filmic tonemapping, and gamma correction.
    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);
}