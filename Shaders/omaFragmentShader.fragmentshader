#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;


 uniform float time;
 uniform float sinTime; 

vec3 objcol;

float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

mat2 rot(float a){
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}

vec2 rotate(vec2 p,float a){
	float c = cos(a);
    float s = sin(a);
    return p*mat2(c,s,-s,c);
}
float map(vec3 p){
    for( int i = 0; i<8; ++i){
        float t = time*1;
        p.xz =rotate(p.xz,t);
        p.xy =rotate(p.xy,t*1.89);
        p.xz = abs(p.xz);
        p.xz-=.5;
	}
	return dot(sign(p),p)/5.;
}
float de(vec3 pos)
{
    float t = mod(time,15.);
    float a=smoothstep(5.,30.,t);
    float jokuFloat =sin(time*1.*.6);

    float sinTest = sin(time * 5);



   pos.xz *= rot(sin(t)+.5);
  // pos.xz *= rot(time+.5);
   pos.yz *= rot(time) * rot(-time * .5);




    vec3 p = pos;
    float s=3.;
    /*
    for (int i=0; i<2; i++){
        p=abs(p)*1.3-.5-jokuFloat*.1-a;
        p.xy*=rot(radians(45.));
        p.xz*=rot(radians(45.));
        p.xyz -= vec3(5. + 3. * sin(t),1,1);
        //p.xyz += vec3(1,1, 1);
        s*=1.3;
    }
    */
    float fractal = length(p)/s-.1;
    //pos.xy *= rot(time);
    p = abs(pos) - 3. - a + sin(time);
    float d = length(p) - .05;

    //d = min(d, max(length(p.xz)-.05,p.y)- (abs(p.y) / 3));
    d = min(d, max(length(p.xz)-.05,p.x) - .5);

    

    p = abs(pos);

    //p.x -= 4.+a+fractal*.5;
    //p.y -= 4.+a+fractal*.5;
    //p.z -= a+fractal;
    //p.x = 4.+a+fractal*.5 * sin(t);


    d = min(d, length(p) - .7);
    //d = min(d, length(p.xy-abs(sin(p.z*.5+time*10.)*3) + vec2(map(sin(t)), 3)));
    //d = min(d, length(p.xz-abs(sin(p.z*.5-time*10.)*.3)));


    p = abs(pos);
    //p.y -= 4.+a+fractal*.2;
    d = min(d, length(p) - .3);


    d = min(d, fractal);
    objcol = abs(pos) / 2;
    if (d==fractal) 
        objcol=vec3(1,0,0);
    return d;
}


vec3 normal(vec3 p) {
    vec2 d = vec2(0., .01);
    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy))-de(p));
}


vec3 march(vec3 from, vec3 dir)
{
    float d = 0., td = 0., maxdist = 50.;
    vec3 p = from, col = vec3(0.);
    for (int i = 0; i<100; i++)
    {
        float d2 = de(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);

        if (d2<0.)
        {
            vec3 n = normal(p);
            dir = reflect(dir, n);
            d2 = .1;
          
        }
        d = max(.01, abs(d2));
        p += d * dir;
        td += d;
        if (td>maxdist) break;
        col += .01 * objcol;
    }
    return pow(col, vec3(2.));
}

// vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - .5;
void main()
{
   

     vec2 uv = (vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - vec2(+0.8, +0.3)) * 2;
     uv.x *= .5f;

    vec3 from = vec3(0.,0.,-10.);
    vec3 dir = normalize(vec3(uv, 1));
    vec3 col = march(from, dir);

    fragColor = vec4(col,1.);
}