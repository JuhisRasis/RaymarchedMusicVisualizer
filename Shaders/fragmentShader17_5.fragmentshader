#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;
     vec2 asd;
 int time_Counter = 0;
 uniform float time;
 bool rotPhase1 = true;
 vec3 objcol;
 bool inLoop = false;
 int loopTimer = 0;
 vec3 boxSize = vec3(3,3,3);


 //code c is the repetition period (which can be different in each coordinate direction). This will work great for primitives that have a bounding box smaller than half the repetition period. 

 mat2 rot(float a){
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}


float sdEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) -.1 + min(max(q.x,max(q.y,q.z)),0.0);
}

 float GetDist(vec3 p){
    vec4 s = vec4(sin(time) * 5, 5, 0., 1);

    float sphereDist = length(p -s.xyz) - s.w;

    float fra = length(p)/1-.5;


    

    float rad = .0;



    rad -= -1.25 *clamp(sin(time * 21.5), 0.6, 1);

    rad -= 0.8*(p.x-p.x/2)*sin(time);

    //p.yz *= rot(sin(time));

    objcol = abs(p) / 8;

    if(sin(time/7) > .5){
    //objcol.x = 0;
    objcol -= vec3(sin(time),0,0);
    rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.y)),1);
    p.xy *= rot(time);
    }
    else{
    //objcol.y = 0;
    p.xz *= rot(time);
    objcol += vec3(0,sin(time),0);
    rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.z)),1);

    }


    float d = length(p) - .7;

    //d = min(d,sdBox(p, boxSize)- .5);





    
    d = min(d,length(p -s.xyz) - .7 -rad);



    vec3 c = vec3(16,16,16);

    vec3 q = mod(p+0.5*c,c)-0.5*c;
    d = sdBox(q, boxSize -.5) -rad;
    d *= 0.9;



    //float planeDist = p.y;
    //d = min(d, planeDist);





    //objcol=vec3(0,1.,1.);


    return d;
 
 }

 vec3 GetNormal(vec3 p){
    float d = GetDist(p);
    vec2 e = vec2(.01, 0);

    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));


        return normalize(n);
 }

  vec3 normal(vec3 p) {
    vec2 d = vec2(0., .01);
    return normalize(vec3(GetDist(p+d.yxx), GetDist(p+d.xyx), GetDist(p+d.xxy))-GetDist(p));
}
 


 float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}



 vec3 March(vec3 from, vec3 dir)
{
    float d = 0., td = 0., maxdist = 50.;
    vec3 p = from, col = vec3(0.);
    vec3 secondMatchDir = dir;

    for (int i = 0; i<100; i++)
    {
        float d2 = GetDist(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);

        if (d2<-0)
        {
            vec3 n = normal(p);
            dir = reflect(dir, n); // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/reflect.xhtml
            d2 = .1;
          
        }
        d = max(.01, abs(d2));
        p += d * dir;

        td += d;
        if (td>maxdist) break;
        col += .01 * objcol;
    }

    //float d3 = RayMarch(from,secondMatchDir);


    //vec3 p2 = from + secondMatchDir * d3;

    //float dif = GetLight(p2);
    //vec3 col2 = vec3(dif);


    return pow(col, vec3(2.));
}


// vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - .5;
void main()
{
   

     vec2 uv = (vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - vec2(+1.1, +0.33)) * 2;
     uv.x *= .5f;

    vec3 from = vec3(2,7 , -22 - sin(time) * 10); // cameraPos
    vec3 dir = normalize(vec3(uv, 1));


    vec3 col = vec3(0);


    col = March(from, dir);



    fragColor = vec4(col,1.0);
}

// Vector multipiclations
// The Vector Dot Product dot() == float
// The Vector Dot Product cross() == vec
// min() Returns the smallest of a and b. If both are equivalent, a is returned.
// abs() return the absolute value of the parameter