#version 330 core

 out vec4 fragColor;
 in vec2 fragCoord;
     vec2 asd;
 int time_Counter = 0;
 uniform float time;
 bool rotPhase1 = true;
 vec3 objcol;
 bool inLoop = false;
 int loopTimer = 0;
 vec3 boxSize = vec3(3,3,3);
 vec3 hue;


 const int mat_base=1;

 mat2 rot(float a){
    float s = sin(a), c = cos(a);
    return mat2(c, s, -s, c);
}





float sdEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) -.1 + min(max(q.x,max(q.y,q.z)),0.0);
}



 float GetDist(vec3 p, vec3 multiplier){
    vec4 s = vec4(time * 15, 0, 0., 0);

    float sphereDist = length(p -s.xyz) - s.w;

    float fra = length(p)/1-.5;




    float rad = .0;


    //21.5
    //rad -= -2 *clamp(sin(time * 22.5), 0.6, 1);

    rad -= .3*sin(p.x)* sin(time * 13);
    rad -= .3*(sin(p.z))*cos(time * 13);


    //rad -= sin(p.x) - sin(p.y);






    if(sin(time/2) > .5){
    //rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.y)),1);
    //p.yx *= rot(time);
        //p.zx *= rot(time);
            p.xz *= rot(sin(time / 4));

    }
    else{
    //p.zx *= rot(0);
    //rad -= 0.5*pow(0.5 +0.5*cos(10.* atan(p.x,p.z)),1);

    }

    float d = length(p) - .7;

    d = min(d,length(p -s.xyz) - .7 -rad);
    boxSize = vec3(1,             1,             1);


    vec3 c = vec3(5,25 + sin(time)*4,5);



    vec3 q = mod(p+0.5*c -s.xyz,c)-0.5*c;
    d = sdEllipsoid(q, boxSize * multiplier -.5) -rad;
    d *= .9;


     //float radiating = 0.1*pow(0.5 +0.5*cos(15.* atan(p.x,p.z) * sin(time)),20);

    float radiating  = .25*(sin((p.z + 2.5) / 1.58));
    float radiating2 = .25*(sin((p.x + 2.5) / 1.58));

    if(radiating<radiating / 2){
    //objcol = abs(p) / 25;
    //hue  += vec3(radiating / 2,radiating / 3,radiating / 100) + vec3(0.02,0.02,0.02);


    }
    else{
    
    hue  += vec3(radiating / 4,radiating /8,radiating / 100) * abs(p) / 25 + vec3(0.02,0.02,0.02);

    }
    return d;
 }



  vec3 normal(vec3 p, vec3 multiplier) {
    vec2 d = vec2(0., .01);
    return normalize(vec3(GetDist(p+d.yxx, multiplier), GetDist(p+d.xyx, multiplier), GetDist(p+d.xxy, multiplier))-GetDist(p, multiplier));
}
 


 float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}



 vec3 March(vec3 from, vec3 dir)
{
    float d = 0., tracingDistance = 0.,tr = 0.,tracer = 0,   maxdist = 150.;
    vec3 p = from, col = vec3(0.), transparent = vec3(0.);
    vec3 startDir = dir;

    for (int i = 0; i<100; i++)
    {



        float d2 = GetDist(p, vec3(4- clamp(sin(time),0,.5),4- clamp(sin(time),0,.5),4- clamp(sin(time),0,.5)));

        /*
        if (d2<0)
        {
            vec3 n = normal(p, vec3(1,1,1));
            d2 = .1;
          
        }
        */

        d = max(.01, d2);
        p += d * dir;
        tracingDistance += d;
        if (tracingDistance>maxdist) break;

        vec3 colourr = mix(objcol, hue, .9);
        col += .007 * hue;
    }





    if(d<2){
    transparent += vec3(5.,5.,5.);

    }
    else{
    transparent -= vec3(5.,5.,5.);

    }






    p = from;
    d = 0.;
    dir = startDir;
    

    

    for (int i = 0; i<100; i++)
    {
        float d3 = GetDist(p, vec3(4 + (sin(p.z * 2)),             5,             4+ (sin(p.x * 2))));

        d = max(.001, d3);
        p += d * dir; //  - vec3(0,-.25,0) * d * dir

        //transparent += vec3(0.02,0.02,0.02);
        
        tracer += d;
        if (tracer>maxdist) break;
        if (d3<-0.01)
        {

            transparent -= vec3(.1,.1,.1);

        }
    }

    vec3 colour = mix(transparent, col,.93f);

    return pow(colour, vec3(1.));
}


// vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - .5;
void main()
{
   

     vec2 uv = (vec2(gl_FragCoord.x / 1080, gl_FragCoord.y /1920) - vec2(+1.1, +0.33)) * 2;
     uv.x *= .5f;
     vec3 from;

    if(sin(time/2) > .5){

    //from = vec3(sin(time)*10 + 1,6 + cos(time) * 1.75,time * 10); // cameraPos

    }
    else{

    }
        from = vec3(0,10 + sin(time) * 1.75,10); // cameraPos

    vec3 dir = normalize(vec3(uv, 1));


    vec3 col = vec3(0);


    col = March(from, dir);



    fragColor = vec4(col,1.0);
}

// Vector multipiclations
// The Vector Dot Product dot() == float
// The Vector Dot Product cross() == vec
// min() Returns the smallest of a and b. If both are equivalent, a is returned.
// abs() return the absolute value of the parameter