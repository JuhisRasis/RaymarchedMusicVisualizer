#version 330 core

in vec3 fragmentColor;
in vec2 vertUV;





out vec4 fragColor;

out vec3 color;
uniform sampler2D texA;
uniform sampler2D texB;
uniform sampler2D texM;

float ns;

float iTime = 23;

//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }
//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }

// Based on Ollj's smooth "fract" formula.
float sFract(float x, float sm) {

    // Extra smoothing factor. "1" is the norm.
    const float sf = 1.;

    // The hardware "fwidth" is cheap, but you could take the expensive route and
    // calculate it by hand if more quality was required.
    vec2 u = vec2(x, fwidth(x) * sf * sm);

    // Ollj's original formula with a transcendental term omitted.
    u.x = fract(u.x);
    u += (1. - 2. * u) * step(u.y, u.x);
    return clamp(1. - u.x / u.y, 0., 1.); // Cos term ommitted.
}

float sFloor(float x) { return x - sFract(x, 1.); }

// Standard hue rotation formula with a bit of streamlining. 
vec3 rotHue(vec3 p, float a) {

    vec2 cs = sin(vec2(1.570796, 0) + a);

    mat3 hr = mat3(0.299, 0.587, 0.114, 0.299, 0.587, 0.114, 0.299, 0.587, 0.114) +
        mat3(0.701, -0.587, -0.114, -0.299, 0.413, -0.114, -0.300, -0.588, 0.886) * cs.x +
        mat3(0.168, 0.330, -0.497, -0.328, 0.035, 0.292, 1.250, -1.050, -0.203) * cs.y;

    return clamp(p * hr, 0., 1.);
}


vec3 hash33(vec3 p) {

    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate
    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put
    // together, based on a couple of other random algorithms I've seen around... so use it with caution,
    // because I make a tonne of mistakes. :)
    float n = sin(dot(p, vec3(7, 157, 113)));
    return fract(vec3(2097152, 262144, 32768) * n) * 2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; 

    // I'll assume the following came from IQ.
    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));
    //return (fract(sin(p)*43758.5453)*2. - 1.);

}

float tetraNoise(in vec3 p)
{
    // Skewing the cubic grid, then determining the first vertice and fractional position.
    vec3 i = floor(p + dot(p, vec3(.333333)));  p -= i - dot(i, vec3(.166666));

    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the 
    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.
    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);

    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.
    // Technically, these are the vectors from "p" to the vertices, but you know what I mean. :)
    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;


    // 3D simplex falloff - based on the squared distance from the fractional position "p" within the 
    // tetrahedron to the four vertice points of the tetrahedron. 
    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);

    // Dotting the fractional position with a random vector, generated for each corner, in order to determine 
    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value 
    // version that works almost as well.
    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));


    // Simplex noise... Not really, but close enough. :)
    return clamp(dot(d, v * v * v * 8.) * 1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.

}


float func(vec2 p) {

    // The noise value.
    float n = tetraNoise(vec3(p.x * 4., p.y * 4., 0) - vec3(0, .25, .5) * iTime);

    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape 
    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.
    // Airtight uses a more interesting triangular version in his "Cartoon Fire" shader.
    float taper = .1 + dot(p, p * vec2(.35, 1));
    n = max(n - taper, 0.) / max(1. - taper, .0001);

    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.
    ns = n;

    // I remember reasoning to myself that the following would take a continuous function ranging
    // from zero to one, then palettize it over "palNum" discreet values between zero and one
    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to 
    // let me know. :)
    const float palNum = 9.;
    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall
    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm 
    // probably overlooking something. Having said that, I don't trust the GPU "fract" function much.
    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);
    return n * .25 + clamp(sFloor(n * (palNum - .001)) / (palNum - 1.), 0., 1.) * .75;

}
float time;
vec2 fragCoord = vec2(0, 360f);
vec2 iResolution = vec2(360f, 360f);
void main()
{
    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.xy;
    time += 1;
    fragCoord = vec2(time, 360f);
    // Function value.
    float f = func(uv);
    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.

    // Four sample values around the original. Used for edging and highlighting.
    vec2 e = vec2(1.5 / iResolution.y, 0);
    float fxl = func(uv + e.xy);
    float fxr = func(uv - e.xy);
    float fyt = func(uv + e.yx);
    float fyb = func(uv - e.yx);

    // Colorizing the function value, and applying some hue rotation based on position.
    // Most of it was made up.
    vec3 col = pow(min(vec3(1.5, 1, 1) * (f * .7 + ssd * .35), 1.), vec3(1, 2., 10) * 2.) + .01;
    col = rotHue(col, -.25 + .4 * length(uv));

    // Applying the dark edges.
    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb)) * 5., 0.);
    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);
    // Resampling with a slightly larger spread to provide some highlighting.
    fxl = func(uv + e.xy * 1.5);
    fyt = func(uv + e.yx * 1.5);

    fragColor.wzyx += vec4(3f,3f,3f,3f); 


	vec3 cA = texture(texA, vertUV).rgb;
	vec3 cB = texture(texB, vertUV).rgb;
	float m = texture(texM, vertUV).r;
	vec3 c = mix(cA, cB, m);
    //color = c;
	col += fragmentColor + vec3(.5, .7, 1) * (max(f - fyt, 0.) + max(f - fxl, 0.)) * ssd * 10.;

    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);
}